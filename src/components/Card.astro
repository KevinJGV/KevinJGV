---
interface Props {
	text: string;
	href: string;
	hrefImages: string[];
	cover?: string;
	txtColor?: string;
	bgColor?: string;
	tags?: { [key: string]: string };
}

const {
	text,
	href,
	hrefImages,
	cover = `<svg xmlns="http://www.w3.org/2000/svg" width="" height="" viewBox="0 0 32 32"><defs><filter id="inset-shadow"><feOffset dx="0" dy="0" /><feGaussianBlur stdDeviation="1" result="offset-blur" /><feComposite operator="out" in="SourceGraphic" in2="offset-blur" result="inverse" /><feFlood flood-color="#838383" flood-opacity="0.8" result="color" /><feComposite operator="in" in="color" in2="inverse" result="shadow" /></filter></defs><g filter="url(#inset-shadow)"><path fill="#fff" d="M20.42 21.157l2.211 2.211L30 16l-7.369-7.369l-2.211 2.212L25.58 16ZM11.58 10.843L9.369 8.631 2 16l7.369 7.369 2.211-2.211L6.42 16Zm5.831-3.166l1.6.437-4.42 16.209-1.6-.437z" /></g></svg>`,
	txtColor = "#fff",
	bgColor = "#fff3",
	tags = {},
} = Astro.props;

// Utilizamos el FileSystem API de Astro en lugar de fetch
import { readFile } from 'node:fs/promises';
import path from 'node:path';

async function readSvgFile(svgPath: string) {
	try {
		const fullPath = path.join("public/", svgPath);
		const svgContent = await readFile(fullPath, 'utf-8');
		return svgContent;
	} catch (error) {
		console.error(`Error reading SVG file: ${error}`);
	}
}

async function tagItem(key: string, svgContent: string) {
	const svg = await readSvgFile(svgContent);
	return `
		<li>
			${svg}
			<span>${key}</span>
		</li>
	`;
}

async function renderTagItem(key: string, setting: string) {
	if (!key.startsWith("template")) {
		return await tagItem(key, setting);
	}

	const tagConfigs = {
		"e-commerce": { label: "E-commerce", path: "tags/function/cart.svg" },
		"technology": { label: "Technologia", path: "tags/purpose/technology.svg" },
		"frontend": { label: "Frontend", path: "tags/role/frontend.svg" },
		"uiux": { label: "UI/UX", path: "tags/role/uiux.svg" },
		"entertainment": { label: "Entretenimiento", path: "tags/purpose/entertainment.svg" },
		"api": { label: "API", path: "tags/type/api.svg" },
		"manager": { label: "Administrador", path: "tags/function/manager.svg" },
		"dashboard": { label: "DashBoard", path: "tags/type/dashboard.svg" },
		"modeling": { label: "Modelado", path: "tags/function/modeling.svg" },
		"business": { label: "Negocio", path: "tags/purpose/business.svg" },
		"leadership": { label: "Líder", path: "tags/role/leadership.svg" },
		"mysql": { label: "MySql", path: "tags/tech/mysql.svg" },
		"db": { label: "DB", path: "tags/type/db.svg" }
	};

	const config = tagConfigs[setting as keyof typeof tagConfigs];
	if (config) {
		return await tagItem(config.label, config.path);
	}
	return '';
}

// Preprocesar los tags para mejorar el rendimiento
const processedTags = await Promise.all(
	Object.entries(tags).map(async ([key, setting]) => 
		await renderTagItem(key, setting)
	)
);
---

<a 
	href={href} 
	class="pCard flex_col glass0 relative" 
	target="_blank" 
	style={`color: ${txtColor}; background-color: ${bgColor};`}
>
	{cover && cover.toLowerCase().endsWith("</svg>") ? (
		<div class="imageCard flex j_c absolute" set:html={cover} />
	) : (
		<div class="imageCard flex j_c absolute">
			<img src={cover} alt="" loading="lazy" />
		</div>
	)}

	<ul class="tags absolute flex">
		{processedTags.map((tag) => (
			<Fragment set:html={tag} />
		))}
	</ul>
	
	<p class="Poppins-S text_center absolute">
		<span>{text}</span>
	</p>

	<div class="card_carousel flex absolute">
		{hrefImages.map((capture) => (
			<img src={capture} alt=""  />
		))}
	</div>
</a>

<script>
	document.addEventListener("DOMContentLoaded", () => {
		const pCards = document.querySelectorAll(".pCard");
		let timeoutId: number | null = null;

		pCards.forEach((card) => {
			const images = card.querySelectorAll(".card_carousel img");
			images[0].classList.add("active");
			let currentIndex = 0;
			let direction = 1;
			let interval: number;

			const startCarousel = () => {
				interval = setInterval(() => {
					images[currentIndex].style.display = "none";
					images[currentIndex].classList.remove("active");
					currentIndex += direction;

					if (currentIndex >= images.length) {
						currentIndex = images.length - 2;
						direction = -1;
					} else if (currentIndex < 0) {
						currentIndex = 1;
						direction = 1;
					}

					images[currentIndex].style.display = "block";
					images[currentIndex].classList.add("active");
				}, 1000);
			};

			const stopCarousel = () => {
				clearInterval(interval);
				images.forEach((img, index) => {
					img.style.display = index === 0 ? "block" : "none";
					img.classList.toggle("active", index === 0);
				});
				currentIndex = 0;
				direction = 1;
			};

			const updateStyles = (hoveredCard) => {
				const styleUpdatesHovered = [
					{
						selector: "p",
						styles: { fontSize: "1rem" },
					},
					{
						selector: ".tags",
						styles: { bottom: "100px" },
					},
					{
						selector: ".imageCard",
						styles: { opacity: "0" },
					},
				];

				const styleUpdatesNonHovered = [
					{
						selector: "p",
						styles: { fontSize: "0" },
					},
				];

				pCards.forEach((otherCard) => {
					if (otherCard === hoveredCard) {
						styleUpdatesHovered.forEach(({ selector, styles }) => {
							const element = otherCard.querySelector(selector);
							if (element) {
								Object.keys(styles).forEach((prop) => {
									element.style[prop] = styles[prop];
								});
							}
						});
					} else {
						styleUpdatesHovered.forEach(({ selector, styles }) => {
							const element = otherCard.querySelector(selector);
							if (element) {
								Object.keys(styles).forEach((prop) => {
									const nonHoveredStyle =
										styleUpdatesNonHovered.find(
											(item) =>
												item.selector === selector,
										);

									if (
										nonHoveredStyle &&
										nonHoveredStyle.styles[prop] !==
											undefined
									) {
										element.style[prop] =
											nonHoveredStyle.styles[prop];
									} else {
										element.style.removeProperty(prop);
									}
								});
							}
						});
					}
				});
			};

			const resetStyles = () => {
				if (timeoutId) clearTimeout(timeoutId);
				timeoutId = setTimeout(() => {
					pCards.forEach((card) => {
						["p", ".tags", ".imageCard"].forEach((selector) => {
							const element = card.querySelector(selector);
							if (element) {
								(element as HTMLElement).style.removeProperty("font-size");
								(element as HTMLElement).style.removeProperty("bottom");
								(element as HTMLElement).style.removeProperty("opacity");
							}
						});
					});
				}, 99);
			};

			card.addEventListener("mouseover", () => {
				debugger;
				startCarousel();
				if (timeoutId) clearTimeout(timeoutId);
				updateStyles(card);
			});

			card.addEventListener("mouseout", () => {
				stopCarousel();
				resetStyles();
			});
		});

		// Función para calcular dimensiones
		const calculateDimensions = () => {
			const cardsContainer = document.querySelector("#projects > div");
			if (!cardsContainer) return;

			const containerWidth = cardsContainer.clientWidth;
			const totalCards = pCards.length;
			const growFactor = 4;
			const shrinkFactor = 1;
			const totalFlex = (totalCards - 1) * shrinkFactor + growFactor;
			const maxCardWidth = Math.round((containerWidth * growFactor) / totalFlex) - 9;

			document.querySelectorAll(".card_carousel").forEach((carousel) => {
				(carousel as HTMLElement).style.width = `${maxCardWidth}px`;
			});

			// Calcular altura máxima
			let maxEstimatedHeight = 0;
			document.querySelectorAll(".card_carousel").forEach((carousel) => {
				carousel.querySelectorAll("img").forEach((img) => {
					const aspectRatio = img.naturalHeight / img.naturalWidth;
					maxEstimatedHeight = Math.max(maxEstimatedHeight, maxCardWidth * aspectRatio);
				});
			});

			pCards.forEach((pCard) => {
				(pCard as HTMLElement).style.setProperty("--carousel-height", `${maxEstimatedHeight}px`);
			});
		};

		// Calcular dimensiones iniciales y en resize
		calculateDimensions();
		let resizeTimeout: number;
		window.addEventListener("resize", () => {
			clearTimeout(resizeTimeout);
			resizeTimeout = setTimeout(calculateDimensions, 200);
		});
	});
</script>

<style define:vars={{ bgColor, txtColor }}>
	.card_carousel img {
		transition: opacity 0.5s ease;
		width: 100%;
	}

	.pCard span {
		min-width: 14em;
		padding: 0.5em;
		text-align: center;
		transform: rotate(-90deg);
		transition: all 0.5s;
		text-transform: uppercase;
		color: var(--txtColor);
		letter-spacing: 0.1em;
	}

	.card_carousel img:first-child {
		display: block;
	}

	.card_carousel img:not(:first-child) {
		display: none;
	}

	.imageCard {
		z-index: 5;
		top: 0;
		left: 0;
		right: 0;
		bottom: 0;
		background-color: var(--bgColor);
		align-items: center;
	}

	.pCard p {
		font-size: 1rem;
		margin: 1rem;
		bottom: 0;
		z-index: 10;
	}

	.pCard .tags {
		list-style: none;
		padding: 0;
		z-index: 8;
		width: 100%;
		height: 20px;
		bottom: -20px;
		background-color: var(--bgColor);
	}
</style>